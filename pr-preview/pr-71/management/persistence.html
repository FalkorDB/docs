<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/assets/css/just-the-docs-default.css"> <link rel="stylesheet" href="/assets/css/just-the-docs-head-nav.css" id="jtd-head-nav-stylesheet"> <style id="jtd-nav-activation"> .site-nav > ul.nav-list:first-child > li:not(:nth-child(16)) > a, .site-nav > ul.nav-list:first-child > li > ul > li a { background-image: none; } .site-nav > ul.nav-list:not(:first-child) a, .site-nav li.external a { background-image: none; } .site-nav > ul.nav-list:first-child > li:nth-child(16) > a { font-weight: 600; text-decoration: none; }.site-nav > ul.nav-list:first-child > li:nth-child(16) > button svg { transform: rotate(-90deg); }.site-nav > ul.nav-list:first-child > li.nav-list-item:nth-child(16) > ul.nav-list { display: block; } </style> <script async src="https://www.googletagmanager.com/gtag/js?id=G-0V4CX90653"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-0V4CX90653'); </script> <script src="/assets/js/vendor/lunr.min.js"></script> <script src="/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="icon" href="/images/favicon.ico" type="image/x-icon"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>Persistence | FalkorDB Docs</title> <meta name="generator" content="Jekyll v3.10.0" /> <meta property="og:title" content="Persistence" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="How FalkorDB writes data to disk" /> <meta property="og:description" content="How FalkorDB writes data to disk" /> <link rel="canonical" href="https://docs.falkordb.com/management/persistence.html" /> <meta property="og:url" content="https://docs.falkordb.com/management/persistence.html" /> <meta property="og:site_name" content="FalkorDB Docs" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Persistence" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"How FalkorDB writes data to disk","headline":"Persistence","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://docs.falkordb.com/images/falkor-logo.png"}},"url":"https://docs.falkordb.com/management/persistence.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header" role="banner"> <a href="/" class="site-title lh-tight"> <div class="site-logo" role="img" aria-label="FalkorDB Docs"></div> </a> <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </button> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/configuration.html" class="nav-list-link">Configuration Parameters</a></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Commands category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/commands/" class="nav-list-link">Commands</a><ul class="nav-list"><li class="nav-list-item"><a href="/commands/graph.query.html" class="nav-list-link">GRAPH.QUERY</a></li><li class="nav-list-item"><a href="/commands/graph.ro_query.html" class="nav-list-link">GRAPH.RO_QUERY</a></li><li class="nav-list-item"><a href="/commands/graph.delete.html" class="nav-list-link">GRAPH.DELETE</a></li><li class="nav-list-item"><a href="/commands/graph.explain.html" class="nav-list-link">GRAPH.EXPLAIN</a></li><li class="nav-list-item"><a href="/commands/graph.list.html" class="nav-list-link">GRAPH.LIST</a></li><li class="nav-list-item"><a href="/commands/graph.profile.html" class="nav-list-link">GRAPH.PROFILE</a></li><li class="nav-list-item"><a href="/commands/graph.config-get.html" class="nav-list-link">GRAPH.CONFIG-GET</a></li><li class="nav-list-item"><a href="/commands/graph.config-set.html" class="nav-list-link">GRAPH.CONFIG-SET</a></li><li class="nav-list-item"><a href="/commands/graph.constraint-create.html" class="nav-list-link">GRAPH.CONSTRAINT CREATE</a></li><li class="nav-list-item"><a href="/commands/graph.constraint-drop.html" class="nav-list-link">GRAPH.CONSTRAINT DROP</a></li><li class="nav-list-item"><a href="/commands/graph.copy.html" class="nav-list-link">GRAPH.COPY</a></li><li class="nav-list-item"><a href="/commands/graph.info.html" class="nav-list-link">GRAPH.INFO</a></li><li class="nav-list-item"><a href="/commands/graph.slowlog.html" class="nav-list-link">GRAPH.SLOWLOG</a></li></ul></li><li class="nav-list-item"><a href="/clients.html" class="nav-list-link">Client Libraries</a></li><li class="nav-list-item"><a href="/datatypes.html" class="nav-list-link">Data types</a></li><li class="nav-list-item"><a href="/path_algorithm.html" class="nav-list-link">Path algorithms</a></li><li class="nav-list-item"><a href="/docker-examples/README.html" class="nav-list-link">Building Docker</a></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Cypher Language category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/cypher/" class="nav-list-link">Cypher Language</a><ul class="nav-list"><li class="nav-list-item"><a href="/cypher/match.html" class="nav-list-link">MATCH</a></li><li class="nav-list-item"><a href="/cypher/optional_match.html" class="nav-list-link">OPTIONAL MATCH</a></li><li class="nav-list-item"><a href="/cypher/where.html" class="nav-list-link">WHERE</a></li><li class="nav-list-item"><a href="/cypher/return.html" class="nav-list-link">RETURN</a></li><li class="nav-list-item"><a href="/cypher/order_by.html" class="nav-list-link">ORDER BY</a></li><li class="nav-list-item"><a href="/cypher/skip.html" class="nav-list-link">SKIP</a></li><li class="nav-list-item"><a href="/cypher/limit.html" class="nav-list-link">LIMIT</a></li><li class="nav-list-item"><a href="/cypher/create.html" class="nav-list-link">CREATE</a></li><li class="nav-list-item"><a href="/cypher/delete.html" class="nav-list-link">DELETE</a></li><li class="nav-list-item"><a href="/cypher/set.html" class="nav-list-link">SET</a></li><li class="nav-list-item"><a href="/cypher/merge.html" class="nav-list-link">MERGE</a></li><li class="nav-list-item"><a href="/cypher/with.html" class="nav-list-link">WITH</a></li><li class="nav-list-item"><a href="/cypher/union.html" class="nav-list-link">UNION</a></li><li class="nav-list-item"><a href="/cypher/unwind.html" class="nav-list-link">UNWIND</a></li><li class="nav-list-item"><a href="/cypher/foreach.html" class="nav-list-link">FOREACH</a></li><li class="nav-list-item"><a href="/cypher/call.html" class="nav-list-link">CALL</a></li><li class="nav-list-item"><a href="/cypher/functions.html" class="nav-list-link">Functions</a></li><li class="nav-list-item"><a href="/cypher/procedures.html" class="nav-list-link">Procedures</a></li><li class="nav-list-item"><a href="/cypher/algorithms.html" class="nav-list-link">Algorithms</a></li><li class="nav-list-item"><a href="/cypher/indexing.html" class="nav-list-link">Indexing</a></li><li class="nav-list-item"><a href="/cypher/cypher_support.html" class="nav-list-link">Cypher coverage</a></li><li class="nav-list-item"><a href="/cypher/known_limitations.html" class="nav-list-link">Known limitations</a></li></ul></li><li class="nav-list-item"><a href="/llm_support.html" class="nav-list-link">LLM frameworks support</a></li><li class="nav-list-item"><a href="/bolt_support.html" class="nav-list-link">BOLT protocol support</a></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Operations category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/operations/" class="nav-list-link">Operations</a><ul class="nav-list"><li class="nav-list-item"><a href="/operations/persistence.html" class="nav-list-link">Persistence</a></li><li class="nav-list-item"><a href="/operations/replication.html" class="nav-list-link">Replication</a></li><li class="nav-list-item"><a href="/operations/cluster.html" class="nav-list-link">Cluster</a></li><li class="nav-list-item"><a href="/operations/k8s_support.html" class="nav-list-link">Kubernetes support</a></li></ul></li><li class="nav-list-item"><a href="/management/" class="nav-list-link">Management</a></li><li class="nav-list-item"><a href="/redisgraph-to-falkordb.html" class="nav-list-link">RedisGraph to FalkorDB</a></li><li class="nav-list-item"><a href="/References.html" class="nav-list-link">References</a></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in The FalkorDB Design category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/design/" class="nav-list-link">The FalkorDB Design</a><ul class="nav-list"><li class="nav-list-item"><a href="/design/client_spec.html" class="nav-list-link">Client Specification</a></li><li class="nav-list-item"><a href="/design/bulk_spec.html" class="nav-list-link">GRAPH.BULK endpoint specification</a></li><li class="nav-list-item"><a href="/design/result_structure.html" class="nav-list-link">Result Set Structure</a></li></ul></li><li class="nav-list-item"><a href="/management/persistence.html" class="nav-list-link">Persistence</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search FalkorDB Docs" aria-label="Search FalkorDB Docs" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> <nav aria-label="Auxiliary" class="aux-nav"> <ul class="aux-nav-list"> <li class="aux-nav-list-item"> <a href="//github.com/falkordb/docs" class="site-button" target="_blank" rel="noopener noreferrer" > Docs Repository </a> </li> <li class="aux-nav-list-item"> <a href="//github.com/falkordb/falkordb" class="site-button" target="_blank" rel="noopener noreferrer" > FalkorDB Repository </a> </li> </ul> </nav> </div> <div class="main-content-wrap"> <div id="main-content" class="main-content"> <main> <p>Persistence refers to the writing of data to durable storage, such as a solid-state disk (SSD). FalkorDB provides a range of persistence options. These include:</p> <ul> <li><strong>RDB</strong> (FalkorDB Database): RDB persistence performs point-in-time snapshots of your dataset at specified intervals.</li> <li><strong>AOF</strong> (Append Only File): AOF persistence logs every write operation received by the server. These operations can then be replayed again at server startup, reconstructing the original dataset. Commands are logged using the same format as the FalkorDB protocol itself.</li> <li><strong>No persistence</strong>: You can disable persistence completely. This is sometimes used when caching.</li> <li><strong>RDB + AOF</strong>: You can also combine both AOF and RDB in the same instance.</li> </ul> <p>To learn more about how to evaluate your FalkorDB persistence strategy, read on.</p> <h2 id="rdb-advantages"> <a href="#rdb-advantages" class="anchor-heading" aria-labelledby="rdb-advantages"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> RDB advantages </h2> <ul> <li>RDB is a very compact single-file point-in-time representation of your FalkorDB data. RDB files are perfect for backups. For instance you may want to archive your RDB files every hour for the latest 24 hours, and to save an RDB snapshot every day for 30 days. This allows you to easily restore different versions of the data set in case of disasters.</li> <li>RDB is very good for disaster recovery, being a single compact file that can be transferred to far data centers, or onto Amazon S3 (possibly encrypted).</li> <li>RDB maximizes FalkorDB performances since the only work the FalkorDB parent process needs to do in order to persist is forking a child that will do all the rest. The parent process will never perform disk I/O or alike.</li> <li>RDB allows faster restarts with big datasets compared to AOF.</li> <li>On replicas, RDB supports partial resynchronizations after restarts and failovers.</li> </ul> <h2 id="rdb-disadvantages"> <a href="#rdb-disadvantages" class="anchor-heading" aria-labelledby="rdb-disadvantages"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> RDB disadvantages </h2> <ul> <li>RDB is NOT good if you need to minimize the chance of data loss in case FalkorDB stops working (for example after a power outage). You can configure different <em>save points</em> where an RDB is produced (for instance after at least five minutes and 100 writes against the data set, you can have multiple save points). However you’ll usually create an RDB snapshot every five minutes or more, so in case of FalkorDB stopping working without a correct shutdown for any reason you should be prepared to lose the latest minutes of data.</li> <li>RDB needs to fork() often in order to persist on disk using a child process. fork() can be time consuming if the dataset is big, and may result in FalkorDB stopping serving clients for some milliseconds or even for one second if the dataset is very big and the CPU performance is not great. AOF also needs to fork() but less frequently and you can tune how often you want to rewrite your logs without any trade-off on durability.</li> </ul> <h2 id="aof-advantages"> <a href="#aof-advantages" class="anchor-heading" aria-labelledby="aof-advantages"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> AOF advantages </h2> <ul> <li>Using AOF FalkorDB is much more durable: you can have different fsync policies: no fsync at all, fsync every second, fsync at every query. With the default policy of fsync every second, write performance is still great. fsync is performed using a background thread and the main thread will try hard to perform writes when no fsync is in progress, so you can only lose one second worth of writes.</li> <li>The AOF log is an append-only log, so there are no seeks, nor corruption problems if there is a power outage. Even if the log ends with a half-written command for some reason (disk full or other reasons) the FalkorDB-check-aof tool is able to fix it easily.</li> <li>FalkorDB is able to automatically rewrite the AOF in background when it gets too big. The rewrite is completely safe as while FalkorDB continues appending to the old file, a completely new one is produced with the minimal set of operations needed to create the current data set, and once this second file is ready FalkorDB switches the two and starts appending to the new one.</li> <li>AOF contains a log of all the operations one after the other in an easy to understand and parse format. You can even easily export an AOF file. For instance even if you’ve accidentally flushed everything using the <code class="language-plaintext highlighter-rouge">FLUSHALL</code> command, as long as no rewrite of the log was performed in the meantime, you can still save your data set just by stopping the server, removing the latest command, and restarting FalkorDB again.</li> </ul> <h2 id="aof-disadvantages"> <a href="#aof-disadvantages" class="anchor-heading" aria-labelledby="aof-disadvantages"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> AOF disadvantages </h2> <ul> <li>AOF files are usually bigger than the equivalent RDB files for the same dataset.</li> <li>AOF can be slower than RDB depending on the exact fsync policy. In general with fsync set to <em>every second</em> performance is still very high, and with fsync disabled it should be exactly as fast as RDB even under high load. Still RDB is able to provide more guarantees about the maximum latency even in the case of a huge write load.</li> </ul> <h2 id="ok-so-what-should-i-use"> <a href="#ok-so-what-should-i-use" class="anchor-heading" aria-labelledby="ok-so-what-should-i-use"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ok, so what should I use? </h2> <p>The general indication you should use both persistence methods is if you want a degree of data safety comparable to what PostgreSQL can provide you.</p> <p>If you care a lot about your data, but still can live with a few minutes of data loss in case of disasters, you can simply use RDB alone.</p> <p>There are many users using AOF alone, but we discourage it since to have an RDB snapshot from time to time is a great idea for doing database backups, for faster restarts, and in the event of bugs in the AOF engine.</p> <p>The following sections will illustrate a few more details about the two persistence models.</p> <h2 id="snapshotting"> <a href="#snapshotting" class="anchor-heading" aria-labelledby="snapshotting"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Snapshotting </h2> <p>By default FalkorDB saves snapshots of the dataset on disk, in a binary file called <code class="language-plaintext highlighter-rouge">dump.rdb</code>. You can configure FalkorDB to have it save the dataset every N seconds if there are at least M changes in the dataset, or you can manually call the <code class="language-plaintext highlighter-rouge">SAVE</code> or <code class="language-plaintext highlighter-rouge">BGSAVE</code> commands.</p> <p>For example, this configuration will make FalkorDB automatically dump the dataset to disk every 60 seconds if at least 1000 keys changed:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>save 60 1000
</code></pre></div></div> <p>This strategy is known as <em>snapshotting</em>.</p> <h3 id="how-it-works"> <a href="#how-it-works" class="anchor-heading" aria-labelledby="how-it-works"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> How it works </h3> <p>Whenever FalkorDB needs to dump the dataset to disk, this is what happens:</p> <ul> <li> <p>FalkorDB <a href="https://linux.die.net/man/2/fork">forks</a>. We now have a child and a parent process.</p> </li> <li> <p>The child starts to write the dataset to a temporary RDB file.</p> </li> <li> <p>When the child is done writing the new RDB file, it replaces the old one.</p> </li> </ul> <p>This method allows FalkorDB to benefit from copy-on-write semantics.</p> <h2 id="append-only-file"> <a href="#append-only-file" class="anchor-heading" aria-labelledby="append-only-file"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Append-only file </h2> <p>Snapshotting is not very durable. If your computer running FalkorDB stops, your power line fails, or you accidentally <code class="language-plaintext highlighter-rouge">kill -9</code> your instance, the latest data written to FalkorDB will be lost. While this may not be a big deal for some applications, there are use cases for full durability, and in these cases FalkorDB snapshotting alone is not a viable option.</p> <p>The <em>append-only file</em> is an alternative, fully-durable strategy for FalkorDB.</p> <p>You can turn on the AOF in your configuration file:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>appendonly yes
</code></pre></div></div> <p>From now on, every time FalkorDB receives a command that changes the dataset (e.g. <code class="language-plaintext highlighter-rouge">SET</code>) it will append it to the AOF. When you restart FalkorDB it will re-play the AOF to rebuild the state.</p> <p>FalkorDB uses a multi part AOF mechanism. That is, the original single AOF file is split into base file (at most one) and incremental files (there may be more than one). The base file represents an initial (RDB or AOF format) snapshot of the data present when the AOF is <a href="#log-rewriting">rewritten</a>. The incremental files contains incremental changes since the last base AOF file was created. All these files are put in a separate directory and are tracked by a manifest file.</p> <h3 id="log-rewriting"> <a href="#log-rewriting" class="anchor-heading" aria-labelledby="log-rewriting"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Log rewriting </h3> <p>The AOF gets bigger and bigger as write operations are performed. For example, if you are incrementing a counter 100 times, you’ll end up with a single key in your dataset containing the final value, but 100 entries in your AOF. 99 of those entries are not needed to rebuild the current state.</p> <p>The rewrite is completely safe. While FalkorDB continues appending to the old file, a completely new one is produced with the minimal set of operations needed to create the current data set, and once this second file is ready FalkorDB switches the two and starts appending to the new one.</p> <p>FalkorDB supports an interesting feature: it is able to rebuild the AOF in the background without interrupting service to clients. Whenever you issue a <code class="language-plaintext highlighter-rouge">BGREWRITEAOF</code>, FalkorDB will write the shortest sequence of commands needed to rebuild the current dataset in memory. FalkorDB will automatically trigger log rewriting automatically (see the example configuration file for more information).</p> <p>When an AOF rewrite is scheduled, the FalkorDB parent process opens a new incremental AOF file to continue writing. The child process executes the rewrite logic and generates a new base AOF. FalkorDB will use a temporary manifest file to track the newly generated base file and incremental file. When they are ready, FalkorDB will perform an atomic replacement operation to make this temporary manifest file take effect. In order to avoid the problem of creating many incremental files in case of repeated failures and retries of an AOF rewrite, FalkorDB introduces an AOF rewrite limiting mechanism to ensure that failed AOF rewrites are retried at a slower and slower rate.</p> <h3 id="how-durable-is-the-append-only-file"> <a href="#how-durable-is-the-append-only-file" class="anchor-heading" aria-labelledby="how-durable-is-the-append-only-file"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> How durable is the append only file? </h3> <p>You can configure how many times FalkorDB will <a href="https://linux.die.net/man/2/fsync"><code class="language-plaintext highlighter-rouge">fsync</code></a> data on disk. There are three options:</p> <ul> <li><code class="language-plaintext highlighter-rouge">appendfsync always</code>: <code class="language-plaintext highlighter-rouge">fsync</code> every time new commands are appended to the AOF. Very very slow, very safe. Note that the commands are appended to the AOF after a batch of commands from multiple clients or a pipeline are executed, so it means a single write and a single fsync (before sending the replies).</li> <li><code class="language-plaintext highlighter-rouge">appendfsync everysec</code>: <code class="language-plaintext highlighter-rouge">fsync</code> every second. Fast enough and you may lose 1 second of data if there is a disaster.</li> <li><code class="language-plaintext highlighter-rouge">appendfsync no</code>: Never <code class="language-plaintext highlighter-rouge">fsync</code>, just put your data in the hands of the Operating System. The faster and less safe method. Normally Linux will flush data every 30 seconds with this configuration, but it’s up to the kernel’s exact tuning.</li> </ul> <p>The suggested (and default) policy is to <code class="language-plaintext highlighter-rouge">fsync</code> every second. It is both fast and relatively safe. The <code class="language-plaintext highlighter-rouge">always</code> policy is very slow in practice, but it supports group commit, so if there are multiple parallel writes FalkorDB will try to perform a single <code class="language-plaintext highlighter-rouge">fsync</code> operation.</p> <h3 id="what-should-i-do-if-my-aof-gets-truncated"> <a href="#what-should-i-do-if-my-aof-gets-truncated" class="anchor-heading" aria-labelledby="what-should-i-do-if-my-aof-gets-truncated"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> What should I do if my AOF gets truncated? </h3> <p>It is possible the server crashed while writing the AOF file, or the volume where the AOF file is stored was full at the time of writing. When this happens the AOF still contains consistent data representing a given point-in-time version of the dataset (that may be old up to one second with the default AOF fsync policy), but the last command in the AOF could be truncated. The latest major versions of FalkorDB will be able to load the AOF anyway, just discarding the last non well formed command in the file. In this case the server will emit a log like the following:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Reading RDB preamble from AOF file...
* Reading the remaining AOF tail...
# !!! Warning: short read while loading the AOF file !!!
# !!! Truncating the AOF at offset 439 !!!
# AOF loaded anyway because aof-load-truncated is enabled
</code></pre></div></div> <p>You can change the default configuration to force FalkorDB to stop in such cases if you want, but the default configuration is to continue regardless of the fact the last command in the file is not well-formed, in order to guarantee availability after a restart.</p> <p>Older versions of FalkorDB may not recover, and may require the following steps:</p> <ul> <li>Make a backup copy of your AOF file.</li> <li> <p>Fix the original file using the <code class="language-plaintext highlighter-rouge">FalkorDB-check-aof</code> tool that ships with FalkorDB:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ FalkorDB-check-aof --fix &lt;filename&gt;
</code></pre></div> </div> </li> <li>Optionally use <code class="language-plaintext highlighter-rouge">diff -u</code> to check what is the difference between two files.</li> <li>Restart the server with the fixed file.</li> </ul> <h3 id="what-should-i-do-if-my-aof-gets-corrupted"> <a href="#what-should-i-do-if-my-aof-gets-corrupted" class="anchor-heading" aria-labelledby="what-should-i-do-if-my-aof-gets-corrupted"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> What should I do if my AOF gets corrupted? </h3> <p>If the AOF file is not just truncated, but corrupted with invalid byte sequences in the middle, things are more complex. FalkorDB will complain at startup and will abort:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Reading the remaining AOF tail...
# Bad file format reading the append only file: make a backup of your AOF file, then use ./FalkorDB-check-aof --fix &lt;filename&gt;
</code></pre></div></div> <p>The best thing to do is to run the <code class="language-plaintext highlighter-rouge">FalkorDB-check-aof</code> utility, initially without the <code class="language-plaintext highlighter-rouge">--fix</code> option, then understand the problem, jump to the given offset in the file, and see if it is possible to manually repair the file: The AOF uses the same format of the FalkorDB protocol and is quite simple to fix manually. Otherwise it is possible to let the utility fix the file for us, but in that case all the AOF portion from the invalid part to the end of the file may be discarded, leading to a massive amount of data loss if the corruption happened to be in the initial part of the file.</p> <h3 id="how-it-works-1"> <a href="#how-it-works-1" class="anchor-heading" aria-labelledby="how-it-works-1"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> How it works </h3> <p>Log rewriting uses the same copy-on-write trick already in use for snapshotting. This is how it works:</p> <p><strong>FalkorDB multi-part AOF</strong></p> <ul> <li> <p>FalkorDB <a href="https://linux.die.net/man/2/fork">forks</a>, so now we have a child and a parent process.</p> </li> <li> <p>The child starts writing the new base AOF in a temporary file.</p> </li> <li> <p>The parent opens a new increments AOF file to continue writing updates. If the rewriting fails, the old base and increment files (if there are any) plus this newly opened increment file represent the complete updated dataset, so we are safe.</p> </li> <li> <p>When the child is done rewriting the base file, the parent gets a signal, and uses the newly opened increment file and child generated base file to build a temp manifest, and persist it.</p> </li> <li> <p>Profit! Now FalkorDB does an atomic exchange of the manifest files so that the result of this AOF rewrite takes effect. FalkorDB also cleans up the old base file and any unused increment files.</p> </li> </ul> <h3 id="how-i-can-switch-to-aof-if-im-currently-using-dumprdb-snapshots"> <a href="#how-i-can-switch-to-aof-if-im-currently-using-dumprdb-snapshots" class="anchor-heading" aria-labelledby="how-i-can-switch-to-aof-if-im-currently-using-dumprdb-snapshots"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> How I can switch to AOF, if I’m currently using dump.rdb snapshots? </h3> <p>If you want to enable AOF in a server that is currently using RDB snapshots, you need to convert the data by enabling AOF via CONFIG command on the live server first.</p> <p><strong>IMPORTANT:</strong> not following this procedure (e.g. just changing the config and restarting the server) can result in data loss!</p> <p>Preparations:</p> <ul> <li>Make a backup of your latest dump.rdb file.</li> <li>Transfer this backup to a safe place.</li> </ul> <p>Switch to AOF on live database:</p> <ul> <li>Enable AOF: <code class="language-plaintext highlighter-rouge">redis-cli config set appendonly yes</code></li> <li>Optionally disable RDB: <code class="language-plaintext highlighter-rouge">redis-cli config set save ""</code></li> <li>Make sure writes are appended to the append only file correctly.</li> <li><strong>IMPORTANT:</strong> Update your <code class="language-plaintext highlighter-rouge">FalkorDB.conf</code> (potentially through <code class="language-plaintext highlighter-rouge">CONFIG REWRITE</code>) and ensure that it matches the configuration above. If you forget this step, when you restart the server, the configuration changes will be lost and the server will start again with the old configuration, resulting in a loss of your data.</li> </ul> <p>Next time you restart the server:</p> <ul> <li>Before restarting the server, wait for AOF rewrite to finish persisting the data. You can do that by watching <code class="language-plaintext highlighter-rouge">INFO persistence</code>, waiting for <code class="language-plaintext highlighter-rouge">aof_rewrite_in_progress</code> and <code class="language-plaintext highlighter-rouge">aof_rewrite_scheduled</code> to be <code class="language-plaintext highlighter-rouge">0</code>, and validating that <code class="language-plaintext highlighter-rouge">aof_last_bgrewrite_status</code> is <code class="language-plaintext highlighter-rouge">ok</code>.</li> <li>After restarting the server, check that your database contains the same number of keys it contained previously.</li> </ul> <h2 id="interactions-between-aof-and-rdb-persistence"> <a href="#interactions-between-aof-and-rdb-persistence" class="anchor-heading" aria-labelledby="interactions-between-aof-and-rdb-persistence"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Interactions between AOF and RDB persistence </h2> <p>FalkorDB makes sure to avoid triggering an AOF rewrite when an RDB snapshotting operation is already in progress, or allowing a <code class="language-plaintext highlighter-rouge">BGSAVE</code> while the AOF rewrite is in progress. This prevents two FalkorDB background processes from doing heavy disk I/O at the same time.</p> <p>When snapshotting is in progress and the user explicitly requests a log rewrite operation using <code class="language-plaintext highlighter-rouge">BGREWRITEAOF</code> the server will reply with an OK status code telling the user the operation is scheduled, and the rewrite will start once the snapshotting is completed.</p> <p>In the case both AOF and RDB persistence are enabled and FalkorDB restarts the AOF file will be used to reconstruct the original dataset since it is guaranteed to be the most complete.</p> <h2 id="backing-up-falkordb-data"> <a href="#backing-up-falkordb-data" class="anchor-heading" aria-labelledby="backing-up-falkordb-data"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Backing up FalkorDB data </h2> <p>Before starting this section, make sure to read the following sentence: <strong>Make Sure to Backup Your Database</strong>. Disks break, instances in the cloud disappear, and so forth: no backups means huge risk of data disappearing into /dev/null.</p> <p>FalkorDB is very data backup friendly since you can copy RDB files while the database is running: the RDB is never modified once produced, and while it gets produced it uses a temporary name and is renamed into its final destination atomically using rename(2) only when the new snapshot is complete.</p> <p>This means that copying the RDB file is completely safe while the server is running. This is what we suggest:</p> <ul> <li>Create a cron job in your server creating hourly snapshots of the RDB file in one directory, and daily snapshots in a different directory.</li> <li>Every time the cron script runs, make sure to call the <code class="language-plaintext highlighter-rouge">find</code> command to make sure too old snapshots are deleted: for instance you can take hourly snapshots for the latest 48 hours, and daily snapshots for one or two months. Make sure to name the snapshots with date and time information.</li> <li>At least one time every day make sure to transfer an RDB snapshot <em>outside your data center</em> or at least <em>outside the physical machine</em> running your FalkorDB instance.</li> </ul> <h3 id="backing-up-aof-persistence"> <a href="#backing-up-aof-persistence" class="anchor-heading" aria-labelledby="backing-up-aof-persistence"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Backing up AOF persistence </h3> <p>If you run a FalkorDB instance with only AOF persistence enabled, you can still perform backups. AOF files are split into multiple files which reside in a single directory determined by the <code class="language-plaintext highlighter-rouge">appenddirname</code> configuration. During normal operation all you need to do is copy/tar the files in this directory to achieve a backup. However, if this is done during a <a href="#log-rewriting">rewrite</a>, you might end up with an invalid backup. To work around this you must disable AOF rewrites during the backup:</p> <ol> <li>Turn off automatic rewrites with<br /> <code class="language-plaintext highlighter-rouge">CONFIG SET</code> <code class="language-plaintext highlighter-rouge">auto-aof-rewrite-percentage 0</code><br /> Make sure you don’t manually start a rewrite (using <code class="language-plaintext highlighter-rouge">BGREWRITEAOF</code>) during this time.</li> <li>Check there’s no current rewrite in progress using<br /> <code class="language-plaintext highlighter-rouge">INFO</code> <code class="language-plaintext highlighter-rouge">persistence</code><br /> and verifying <code class="language-plaintext highlighter-rouge">aof_rewrite_in_progress</code> is 0. If it’s 1, then you’ll need to wait for the rewrite to complete.</li> <li>Now you can safely copy the files in the <code class="language-plaintext highlighter-rouge">appenddirname</code> directory.</li> <li>Re-enable rewrites when done:<br /> <code class="language-plaintext highlighter-rouge">CONFIG SET</code> <code class="language-plaintext highlighter-rouge">auto-aof-rewrite-percentage &lt;prev-value&gt;</code></li> </ol> <p><strong>Note:</strong> If you want to minimize the time AOF rewrites are disabled you may create hard links to the files in <code class="language-plaintext highlighter-rouge">appenddirname</code> (in step 3 above) and then re-enable rewrites (step 4) after the hard links are created. Now you can copy/tar the hardlinks and delete them when done. This works because FalkorDB guarantees that it only appends to files in this directory, or completely replaces them if necessary, so the content should be consistent at any given point in time.</p> <p><strong>Note:</strong> If you want to handle the case of the server being restarted during the backup and make sure no rewrite will automatically start after the restart you can change step 1 above to also persist the updated configuration via <code class="language-plaintext highlighter-rouge">CONFIG REWRITE</code>. Just make sure to re-enable automatic rewrites when done (step 4) and persist it with another <code class="language-plaintext highlighter-rouge">CONFIG REWRITE</code>.</p> <h2 id="disaster-recovery"> <a href="#disaster-recovery" class="anchor-heading" aria-labelledby="disaster-recovery"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Disaster recovery </h2> <p>Disaster recovery in the context of FalkorDB is basically the same story as backups, plus the ability to transfer those backups in many different external data centers. This way data is secured even in the case of some catastrophic event affecting the main data center where FalkorDB is running and producing its snapshots.</p> <p>We’ll review the most interesting disaster recovery techniques that don’t have too high costs.</p> <ul> <li>Amazon S3 and other similar services are a good way for implementing your disaster recovery system. Simply transfer your daily or hourly RDB snapshot to S3 in an encrypted form. You can encrypt your data using <code class="language-plaintext highlighter-rouge">gpg -c</code> (in symmetric encryption mode). Make sure to store your password in many different safe places (for instance give a copy to the most important people of your organization). It is recommended to use multiple storage services for improved data safety.</li> <li>Transfer your snapshots using SCP (part of SSH) to far servers. This is a fairly simple and safe route: get a small VPS in a place that is very far from you, install ssh there, and generate a ssh client key without passphrase, then add it in the <code class="language-plaintext highlighter-rouge">authorized_keys</code> file of your small VPS. You are ready to transfer backups in an automated fashion. Get at least two VPS in two different providers for best results.</li> </ul> <p>It is important to understand that this system can easily fail if not implemented in the right way. At least, make absolutely sure that after the transfer is completed you are able to verify the file size (that should match the one of the file you copied) and possibly the SHA1 digest, if you are using a VPS.</p> <p>You also need some kind of independent alert system if the transfer of fresh backups is not working for some reason.</p> </main> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
